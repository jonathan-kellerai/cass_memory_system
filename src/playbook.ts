import fs from "node:fs/promises";
import path from "node:path";
import { parse, stringify } from "yaml";
import {
  Playbook,
  PlaybookBullet,
  NewBulletData,
  PlaybookSchema,
  Config,
  DeprecatedPattern,
} from "./types.js";
import { generateBulletId, extractAgentFromPath, warn, error, expandPath } from "./utils.js";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

async function backupFile(filePath: string): Promise<void> {
  try {
    await fs.access(filePath);
  } catch {
    return; // nothing to backup
  }
  const backupPath = `${filePath}.backup.${Date.now()}`;
  try {
    await fs.cp(filePath, backupPath);
    warn(`Playbook validation failed; backed up to ${backupPath}`);
  } catch (err: any) {
    error(`Failed to backup ${filePath}: ${err.message}`);
  }
}

function ensurePlaybookDefaults(playbook: Playbook): Playbook {
  // schema defaults handled by Zod, but ensure arrays exist to be safe
  playbook.deprecatedPatterns ||= [];
  playbook.bullets ||= [];
  return playbook;
}

// ---------------------------------------------------------------------------
// Core API
// ---------------------------------------------------------------------------

export function createEmptyPlaybook(name = "playbook"): Playbook {
  return {
    schema_version: 2,
    name,
    description: "Auto-generated by cass-memory",
    metadata: {
      createdAt: new Date().toISOString(),
      totalReflections: 0,
      totalSessionsProcessed: 0,
    },
    deprecatedPatterns: [],
    bullets: [],
  };
}

export async function loadPlaybookFromPath(playbookPath: string): Promise<Playbook> {
  const resolved = expandPath(playbookPath);
  try {
    const fileContent = await fs.readFile(resolved, "utf-8");
    if (!fileContent.trim()) return createEmptyPlaybook();

    const parsed = parse(fileContent);
    const result = PlaybookSchema.safeParse(parsed);
    if (!result.success) {
      await backupFile(resolved);
      return createEmptyPlaybook();
    }
    return ensurePlaybookDefaults(result.data);
  } catch (err: any) {
    if (err.code === "ENOENT") return createEmptyPlaybook();
    if (err.code === "EACCES") throw err;
    await backupFile(resolved);
    return createEmptyPlaybook();
  }
}

export async function loadPlaybook(config: Config): Promise<Playbook> {
  return loadPlaybookFromPath(config.playbookPath);
}

export async function savePlaybook(playbook: Playbook, target: Config | string): Promise<void> {
  const playbookPath = typeof target === "string" ? expandPath(target) : expandPath(target.playbookPath);
  const dir = path.dirname(playbookPath);
  await fs.mkdir(dir, { recursive: true });

  // Update metadata
  playbook.metadata = playbook.metadata || {
    createdAt: new Date().toISOString(),
    totalReflections: 0,
    totalSessionsProcessed: 0,
  };
  playbook.metadata.lastReflection = new Date().toISOString();
  playbook.metadata.totalReflections = (playbook.metadata.totalReflections ?? 0) + 1;

  const yamlString = stringify(playbook);
  const tmp = `${playbookPath}.tmp`;
  await fs.writeFile(tmp, yamlString, "utf-8");
  await fs.rename(tmp, playbookPath); // atomic on POSIX
}

export async function loadMergedPlaybook(config: Config, cwd: string = process.cwd()): Promise<Playbook> {
  const globalPath = expandPath("~/.cass-memory/playbook.yaml");
  const repoPath = expandPath(path.join(cwd, ".cass", "playbook.yaml"));

  const global = await loadPlaybookFromPath(globalPath);
  const repo = await loadPlaybookFromPath(repoPath);

  return mergePlaybooks(global, repo);
}

export function mergePlaybooks(global: Playbook, repo: Playbook | null): Playbook {
  if (!repo) return global;

  const merged: Playbook = {
    schema_version: 2,
    name: repo.name || global.name,
    description: repo.description || global.description,
    metadata: repo.metadata || global.metadata,
    deprecatedPatterns: [...(global.deprecatedPatterns || []), ...(repo.deprecatedPatterns || [])],
    bullets: [],
  };

  const byId = new Map<string, PlaybookBullet>();
  for (const b of global.bullets) byId.set(b.id, b);
  for (const b of repo.bullets) byId.set(b.id, b); // repo overrides
  merged.bullets = Array.from(byId.values());
  return merged;
}

export function findBullet(playbook: Playbook, id: string): PlaybookBullet | undefined {
  return playbook.bullets.find((b) => b.id === id);
}

export function addBullet(
  playbook: Playbook,
  data: NewBulletData,
  sourceSession: string,
  config?: Config
): PlaybookBullet {
  const now = new Date().toISOString();
  const bullet: PlaybookBullet = {
    id: generateBulletId(),
    scope: data.scope ?? "global",
    scopeKey: data.workspace,
    workspace: data.workspace,
    category: data.category,
    content: data.content,
    searchPointer: data.searchPointer,
    type: data.type ?? "rule",
    isNegative: data.type === "anti-pattern",
    kind: data.kind ?? "stack_pattern",
    state: "draft",
    maturity: "candidate",
    promotedAt: undefined,
    helpfulCount: 0,
    harmfulCount: 0,
    feedbackEvents: [],
    helpfulEvents: [],
    harmfulEvents: [],
    lastValidatedAt: undefined,
    confidenceDecayHalfLifeDays: config?.defaultDecayHalfLife ?? 90,
    createdAt: now,
    updatedAt: now,
    pinned: false,
    pinnedReason: undefined,
    deprecated: false,
    replacedBy: undefined,
    deprecationReason: undefined,
    sourceSessions: [sourceSession],
    sourceAgents: [extractAgentFromPath(sourceSession)],
    reasoning: undefined,
    tags: data.tags ?? [],
    embedding: undefined,
  };

  playbook.bullets.push(bullet);
  return bullet;
}

export function updateBullet(
  playbook: Playbook,
  id: string,
  updates: Partial<PlaybookBullet>
): boolean {
  const bullet = findBullet(playbook, id);
  if (!bullet) return false;
  const { id: _id, createdAt: _c, ...rest } = updates; // prevent ID/createdAt mutation
  Object.assign(bullet, rest);
  bullet.updatedAt = new Date().toISOString();
  return true;
}

export function deprecateBullet(
  playbook: Playbook,
  bulletId: string,
  reason: string,
  replacedBy?: string
): void {
  const bullet = findBullet(playbook, bulletId);
  if (!bullet) return;
  bullet.deprecated = true;
  bullet.state = "retired";
  bullet.maturity = "deprecated";
  bullet.deprecationReason = reason;
  bullet.replacedBy = replacedBy;
  bullet.updatedAt = new Date().toISOString();

  // Record tombstone
  const tombstone: DeprecatedPattern = {
    pattern: bullet.content,
    deprecatedAt: bullet.updatedAt,
    reason,
    replacement: replacedBy,
  };
  playbook.deprecatedPatterns.push(tombstone);
}

export function getActiveBullets(playbook: Playbook): PlaybookBullet[] {
  return playbook.bullets.filter(
    (b) => b.state !== "retired" && b.maturity !== "deprecated" && !b.deprecated
  );
}

export function getBulletsByCategory(playbook: Playbook, category: string): PlaybookBullet[] {
  return getActiveBullets(playbook).filter(
    (b) => b.category.toLowerCase() === category.toLowerCase()
  );
}
