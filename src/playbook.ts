import { parse, stringify } from 'yaml';
import fs from 'node:fs/promises';
import path from 'node:path';
import { Playbook, PlaybookBullet, Config, NewBulletData, PlaybookSchema } from './types';
import { generateBulletId, extractAgentFromPath, warn, error } from './utils';

const DEFAULT_DECAY_HALF_LIFE_DAYS = 90;

export function createEmptyPlaybook(): Playbook {
  return {
    schema_version: 2,
    name: 'playbook',
    description: 'Auto-generated by cass-memory',
    metadata: {
      createdAt: new Date().toISOString(),
      totalReflections: 0,
      totalSessionsProcessed: 0,
    },
    deprecatedPatterns: [],
    bullets: [],
  };
}

async function backupCorruptFile(playbookPath: string) {
  const backupPath = `${playbookPath}.backup.${Date.now()}`;
  try {
    await fs.cp(playbookPath, backupPath);
    warn(`Corrupted playbook backed up to ${backupPath}`);
  } catch (backupError) {
    error(`Failed to backup corrupted playbook: ${backupError}`);
  }
}

export async function loadPlaybook(config: Config): Promise<Playbook> {
  const playbookPath = path.resolve(config.playbookPath);

  try {
    const fileContent = await fs.readFile(playbookPath, 'utf-8');
    if (!fileContent.trim()) {
      return createEmptyPlaybook();
    }

    const parsed = parse(fileContent);
    const result = PlaybookSchema.safeParse(parsed);

    if (!result.success) {
      warn(`Playbook schema validation failed: ${result.error.message}`);
      await backupCorruptFile(playbookPath);
      return createEmptyPlaybook();
    }

    return result.data;
  } catch (err: any) {
    if (err?.code === 'ENOENT') {
      return createEmptyPlaybook();
    }

    if (err?.code === 'EACCES') {
      throw err;
    }

    await backupCorruptFile(playbookPath);
    return createEmptyPlaybook();
  }
}

export async function savePlaybook(playbook: Playbook, config: Config): Promise<void> {
  const playbookPath = path.resolve(config.playbookPath);

  playbook.schema_version ||= 2;
  playbook.metadata = playbook.metadata || {
    createdAt: new Date().toISOString(),
    totalReflections: 0,
    totalSessionsProcessed: 0,
  };

  playbook.metadata.lastReflection = new Date().toISOString();
  playbook.metadata.totalReflections = (playbook.metadata.totalReflections ?? 0) + 1;
  playbook.metadata.totalSessionsProcessed = playbook.metadata.totalSessionsProcessed ?? 0;

  const dir = path.dirname(playbookPath);
  await fs.mkdir(dir, { recursive: true });

  const yamlString = stringify(playbook);
  const tmpPath = `${playbookPath}.tmp`;

  await fs.writeFile(tmpPath, yamlString, 'utf-8');
  await fs.rename(tmpPath, playbookPath);
}

export function findBullet(
  playbook: Playbook,
  bulletId: string
): PlaybookBullet | undefined {
  return playbook.bullets.find((bullet) => bullet.id === bulletId);
}

export function addBullet(
  playbook: Playbook,
  data: NewBulletData,
  sourceSession: string,
  config?: Config
): PlaybookBullet {
  const now = new Date().toISOString();
  const bullet: PlaybookBullet = {
    id: generateBulletId(),
    scope: data.scope ?? 'global',
    scopeKey: undefined,
    workspace: data.workspace,
    category: data.category,
    content: data.content,
    searchPointer: data.searchPointer,
    type: data.type ?? 'rule',
    isNegative: false,
    kind: data.kind ?? 'stack_pattern',
    state: 'draft',
    maturity: 'candidate',
    promotedAt: undefined,
    helpfulCount: 0,
    harmfulCount: 0,
    feedbackEvents: [],
    helpfulEvents: [],
    harmfulEvents: [],
    lastValidatedAt: undefined,
    confidenceDecayHalfLifeDays:
      config?.defaultDecayHalfLife ?? DEFAULT_DECAY_HALF_LIFE_DAYS,
    createdAt: now,
    updatedAt: now,
    pinned: false,
    pinnedReason: undefined,
    deprecated: false,
    replacedBy: undefined,
    deprecationReason: undefined,
    sourceSessions: [sourceSession],
    sourceAgents: [extractAgentFromPath(sourceSession)],
    reasoning: undefined,
    tags: data.tags ?? [],
    embedding: undefined,
  };

  playbook.bullets.push(bullet);
  return bullet;
}
